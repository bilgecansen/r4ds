<!-- Editöre notlar: 
1. Wrangle bölümü çevrilmemiş gözüküyor, hangi kelime kullanıldığını bilmediğimden wrangle olarak bıraktım satırda. Ayrıca fonksiyonların da türkçesini göremedim. oradaki "conditional execution" başlığına da crossref var. Onu da aynen bıraktım.
2. Double veri tipi için ne kullanıldığını bulamadım, double olarak bıraktım. 
3. String ortak sözlük dosyasında dizi olarak girilmiş ancak dizge olarak kullanımına aşinayım. Ve dizinin hiç bir şekilde karakter izlenimi yaratmadığını kafa karıştırıcı olabileceğini düşünüyorum. Bu sebeple dizge (string) olarak kullandım. Aynı şekilde strings bölümü Dizi olarak çevrilmiş - böyle kalıp kalmayacağından emin olmadığım için o bölüme olan cross-refi strings olarak bıraktım.
4. Floating point numbers kayan noktalı sayı olarak kullanılıyormuş: https://tr.wikipedia.org/wiki/Kayan_nokta ama bu da çok anlamsız gelebilir okuyucuya belki. Kayan noktalı sayı olarak kullandım ama belki gerçel ya da gerçek sayı demeliyim? 
5. Offset i kaydırma olarak çevirdim.
6. Aggregate i yığın olarak kullandım. Toplam olarak çevriliyor sanırım ama bu sum()a karşılık gelecek ve kafa karışacak diye kullanmak istemedim. 
7. pipes chapterına cross ref var ancak pipes çevirisinde cross ref oluşturulmamış, onu pipes olarak bıraktım. (### Pipe ile birden fazla işlemi birleştirmek başlığı altında)-->

<!-- # Data transformation {#transform} -->

# Veri Dönüşümü {#transform}

<!-- ## Introduction -->

## Giriş

<!-- Visualisation is an important tool for insight generation, but it is rare that you get the data in exactly the right form you need. Often you'll need to create some new variables or summaries, or maybe you just want to rename the variables or reorder the observations in order to make the data a little easier to work with. You'll learn how to do all that (and more!) in this chapter, which will teach you how to transform your data using the dplyr package and a new dataset on flights departing New York City in 2013. -->

Görselleştirme, fikir üretme için önemli bir araçtır, ancak verileri tam olarak ihtiyacınız olan biçimde elde etmeniz nadirdir. Genellikle bazı yeni değişkenler veya özetler oluşturmanız gerekir, ya da sadece verilerle çalışmayı biraz daha kolay hale getirmek için değişkenleri yeniden adlandırmak veya gözlemleri yeniden sıralamak istersiniz. Tüm bunları (ve daha fazlasını!) nasıl yapacağınızı dplyr paketini kullanarak veri dönüştürmeyi ve 2013'te New York City'den kalkan uçuşları içeren bir verisetini öğretecek bu bölümde öğreneceksiniz.

<!-- ### Prerequisites -->

### Ön koşullar

<!-- In this chapter we're going to focus on how to use the dplyr package, another core member of the tidyverse. We'll illustrate the key ideas using data from the nycflights13 package, and use ggplot2 to help us understand the data.  -->

Bu bölümde, tidyverse'un bir başka çekirdek üyesi olan dplyr paketinin nasıl kullanılacağına odaklanacağız. Nycflights13 paketindeki verileri kullanarak temel fikirleri açıklayacağız ve verileri anlamamıza yardımcı olması için ggplot2'yi kullanacağız.

```{r setup, message = FALSE}
library(nycflights13)
library(tidyverse)
```

<!-- Take careful note of the conflicts message that's printed when you load the tidyverse. It tells you that dplyr overwrites some functions in base R. If you want to use the base version of these functions after loading dplyr, you'll need to use their full names: `stats::filter()` and `stats::lag()`. -->

Tidyverse'i yüklerken yazdırılan çakışma mesajına dikkat edin. dplyr'ın R tabanındaki bazı işlevlerin üzerine yazdığını söyler. dplyr yüklendikten sonra bu işlevlerin temel sürümünü kullanmak istiyorsanız, tam adlarını kullanmanız gerekir: `stats::filter()` ve `stats::lag()`.

<!-- ### nycflights13 -->

### nycflights13

To explore the basic data manipulation verbs of dplyr, we'll use `nycflights13::flights`. This data frame contains all `r format(nrow(nycflights13::flights), big.mark = ",")` flights that departed from New York City in 2013. The data comes from the US [Bureau of Transportation Statistics](http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0), and is documented in `?flights`.

dplyr'in temel veri işleme fiillerini keşfetmek için `nycflights13::flights` kullanacağız. Bu veri tablosu 2013ite New York City'den kalkmış olan tüm `r format(nrow(nycflights13::flights), big.mark = ",")` uçuşu içerir. Veriler ABD [Ulaştırma İstatistikleri Bürosu](http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0)'ndan geliyor ve `?flights` altında belgelendirilmiştir.
(http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&Link=0)

```{r}
flights
```

<!-- You might notice that this data frame prints a little differently from other data frames you might have used in the past: it only shows the first few rows and all the columns that fit on one screen. (To see the whole dataset, you can run `View(flights)` which will open the dataset in the RStudio viewer). It prints differently because it's a __tibble__. Tibbles are data frames, but slightly tweaked to work better in the tidyverse. For now, you don't need to worry about the differences; we'll come back to tibbles in more detail in [wrangle](#wrangle-intro). -->

Bu veri tablosunun geçmişte kullanmış olabileceğiniz diğer veri tablolarından biraz farklı yazdırıldığını fark edebilirsiniz: yalnızca ilk birkaç satırı ve bir ekrana sığan sütunları gösterir. (Verisetinin tamamını görmek için, verisetini RStudio görüntüleyicisinde açacak olan `View(flights)` komutunu çalıştırabilirsiniz). Farklı yazdırılıyor çünkü bu bir __tibble__. Tibble'lar veri tablolarıdır, ancak tidyverse ile daha iyi çalışabilmek için biraz ayarlanmıştır. Şimdilik farklar konusunda endişelenmenize gerek yok; tibble'lar konusuna daha detaylı olarak [wrangle](#wrangle-intro) bölümünde geri döneceğiz.
 
<!-- You might also have noticed the row of three (or four) letter abbreviations under the column names. These describe the type of each variable: -->

<!-- * `int` stands for integers. -->

<!-- * `dbl` stands for doubles, or real numbers. -->

<!-- * `chr` stands for character vectors, or strings. -->

<!-- * `dttm` stands for date-times (a date + a time). -->

Ayrıca sütun adlarının altındaki üç (veya dört) harfli kısaltma satırını da fark etmiş olabilirsiniz. Bunlar her değişkenin türünü tanımlar:

* `int` tamsayı anlamına gelir.

* `dbl` "double" ya da gerçek sayı anlamına gelir.

* `chr` karakter veya dizge (string) anlamına gelir.

* `dttm` tarih-zaman (bir tarih + bir zaman) anlamına gelir.

<!-- There are three other common types of variables that aren't used in this dataset but you'll encounter later in the book: -->

<!-- * `lgl` stands for logical, vectors that contain only `TRUE` or `FALSE`. -->

<!-- * `fctr` stands for factors, which R uses to represent categorical variables -->
<!--   with fixed possible values. -->

<!-- * `date` stands for dates. -->

Bu veri kümesinde kullanılmayan ancak kitapta daha sonra karşılaşacağınız üç yaygın değişken türü daha vardır:

* `lgl` mantıksal anlamına gelir, sadece `TRUE` ve `FALSE` içeren vektörlerdir.

* `fctr` faktör anlamına gelr, R bunları olası değerleri önceden belirlenmiş kategorik değişkenleri temsil etmek için kullanır.

* `date` tarih anlamına gelir. 

<!-- ### dplyr basics -->

### dplyr temelleri

<!-- In this chapter you are going to learn the five key dplyr functions that allow you to solve the vast majority of your data manipulation challenges: -->

<!-- * Pick observations by their values (`filter()`). -->
<!-- * Reorder the rows (`arrange()`). -->
<!-- * Pick variables by their names (`select()`). -->
<!-- * Create new variables with functions of existing variables (`mutate()`). -->
<!-- * Collapse many values down to a single summary (`summarise()`). -->

Bu bölümde, veri işleme zorluklarınızın büyük çoğunluğunu çözmenizi sağlayacak veren beş temel dplyr fonksiyonunu öğreneceksiniz:

* Değerlerine göre gözlemleri seçme (`filter()`).
* Satırları yeniden sıralama (`arrange()`).
* İsimlerine göre değişkenleri seçme (`select()`).
* Mevcut değişkenlerin fonksiyonları ile yeni değişkenler oluşturma (`mutate()`).
* Çok sayıda değeri tek bir özete indirgeme (`summarise()`).

<!-- These can all be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. These six functions provide the verbs for a language of data manipulation. -->

Bunların hepsi, her işlevin kapsamını tüm veri kümesi yerine gruplarda çalışacak şekilde değiştiren `group_by()` ile birlikte kullanılabilir. Bu altı işlev, bir veri işleme dili için fiilleri sağlar.

<!-- All verbs work similarly:  -->

<!-- 1.  The first argument is a data frame. -->

<!-- 1.  The subsequent arguments describe what to do with the data frame, -->
<!--     using the variable names (without quotes). -->

<!-- 1.  The result is a new data frame. -->

Tüm fiiller benzer şekilde çalışır:

1. İlk argüman bir veri tablosudur.

1. Sonraki argümanlar, değişken adlarını (tırnak işaretleri olmadan) kullanarak veri çerçevesiyle ne yapılacağını açıklar.
    
1. Sonuç yeni bir veri tablosudur.

<!-- Together these properties make it easy to chain together multiple simple steps to achieve a complex result. Let's dive in and see how these verbs work. -->

Bu özellikler birlikte, birden çok basit adımı birbirine zincirleyerek karmaşık sonuçlar elde etmeyi kolaylaştırır. İçeri girelim ve bu fiillerin nasıl çalıştığını görelim.

<!-- ## Filter rows with `filter()` -->

## `filter()` ile satırları filtreleme

<!-- `filter()` allows you to subset observations based on their values. The first argument is the name of the data frame. The second and subsequent arguments are the expressions that filter the data frame. For example, we can select all flights on January 1st with: -->

`filter()`, gözlemleri değerlerine göre alt kümeye almanızı sağlar. İlk argüman veri tablosunun adıdır. İkinci ve sonraki argümanlar, veri tablosunu filtreleyen ifadelerdir. Örneğin, 1 Ocak'taki tüm uçuşları şu şekilde seçebiliriz:

```{r}
filter(flights, month == 1, day == 1)
```

<!-- When you run that line of code, dplyr executes the filtering operation and returns a new data frame. dplyr functions never modify their inputs, so if you want to save the result, you'll need to use the assignment operator, `<-`: -->

Bu kod satırını çalıştırdığınızda, dplyr filtreleme işlemini yürütür ve yeni bir veri tablosu verir. dplyr işlevleri girdi olarak verilen veriyi asla değiştirmez, bu nedenle sonucu kaydetmek isterseniz, atama operatörünü kullanmanız gerekir: `<-`:

```{r}
jan1 <- filter(flights, month == 1, day == 1)
```

<!-- R either prints out the results, or saves them to a variable. If you want to do both, you can wrap the assignment in parentheses: -->

R sonuçları ya yazdırır ya da bir değişkene kaydeder. Her ikisini de yapmak istiyorsanız, atama işlemini parantez içine alabilirsiniz:

```{r}
(dec25 <- filter(flights, month == 12, day == 25))
```

<!-- ### Comparisons -->

### Karşılaştırmalar

<!-- To use filtering effectively, you have to know how to select the observations that you want using the comparison operators. R provides the standard suite: `>`, `>=`, `<`, `<=`, `!=` (not equal), and `==` (equal).  -->

Filtrelemeyi etkili bir şekilde kullanmak için karşılaştırma operatörlerini kullanarak istediğiniz gözlemleri nasıl seçeceğinizi bilmeniz gerekir. R standart paketi sağlar: `>`, `>=`, `<`, `<=`, `!=` (eşit değildir), ve `==` (eşittir). 

<!-- When you're starting out with R, the easiest mistake to make is to use `=` instead of `==` when testing for equality. When this happens you'll get an informative error: -->

R'a yeni başlarken, en kolay hata eşitliği test ederken `==` yerine `=` kullanmaktır. Bu olduğunda, bilgilendirici bir hata alırsınız:

```{r, error = TRUE}
filter(flights, month = 1)
```

<!-- There's another common problem you might encounter when using `==`: floating point numbers. These results might surprise you! -->

`==` kullanırken karşılaşabileceğiniz başka bir yaygın sorun daha var: kayan noktalı sayılar. Bu sonuçlar sizi şaşırtabilir!

```{r}
sqrt(2) ^ 2 == 2
1 / 49 * 49 == 1
```

<!-- Computers use finite precision arithmetic (they obviously can't store an infinite number of digits!) so remember that every number you see is an approximation. Instead of relying on `==`, use `near()`: -->

Bilgisayarlar sonlu aritmetik kullanırlar (tabii ki sonsuz sayıda basamak saklayamazlar!). Bu nedenle, gördüğünüz her sayının bir tahmin olduğunu unutmayın. `==` operatörüne güvenmek yerine `near()` kullanın:

```{r}
near(sqrt(2) ^ 2,  2)
near(1 / 49 * 49, 1)
```

<!-- ### Logical operators -->

### Mantıksal operatörler

<!-- Multiple arguments to `filter()` are combined with "and": every expression must be true in order for a row to be included in the output. For other types of combinations, you'll need to use Boolean operators yourself: `&` is "and", `|` is "or", and `!` is "not". Figure \@ref(fig:bool-ops) shows the complete set of Boolean operations. -->

`filter()` içindeki argümanlar "ve" ile bağlanır: çıktıda bir satırın yer alması için tüm ifadelerin doğru olması gerekir. Diğer birleştirme argümanları için, Boolean (mantıksal) operatörleri kullanmanız gerekir: `&` "ve", `|` "veya", ve `!` "değildir". Tüm mantıksal operatörler Figür \@ref(fig:bool-ops)de verilmiştir.

<!-- ```{r bool-ops, echo = FALSE, fig.cap = "Complete set of boolean operations. `x` is the left-hand circle, `y` is the right-hand circle, and the shaded region show which parts each operator selects."} -->
<!-- knitr::include_graphics("diagrams/transform-logical.png") -->
<!-- ``` -->

```{r bool-ops, echo = FALSE, fig.cap = "Tüm mantıksal operatörler. x sol çember, y sağ çember ve gölgeli bölge her operatörün hangi parçaları seçtiğini gösterir."}
knitr::include_graphics("diagrams/transform-logical.png")
```

The following code finds all flights that departed in November or December:

Aşağıdaki kod, Kasım veya Aralık ayında kalkan tüm uçuşları bulur:

```{r, eval = FALSE}
filter(flights, month == 11 | month == 12)
```

<!-- The order of operations doesn't work like English. You can't write `filter(flights, month == 11 | 12)`, which you might literally translate into  "finds all flights that departed in November or December". Instead it finds all months that equal `11 | 12`, an expression that evaluates to `TRUE`. In a numeric context (like here), `TRUE` becomes one, so this finds all flights in January, not November or December. This is quite confusing! -->

Operatörlerin sırası Türkçe'de olduğu gibi işlemez. Kelimesi kelimesine "Kasım ya da Aralık ayındaki tüm uçuları bul" olarak çevirebileceğiniz `filter(flights, month == 11 | 12)` komutunu yazamazsınız. Bu onun yerine, `11 | 12`ye eşit olan tüm ayları bulur, bu ifade de `TRUE`dır. Sayısal bir bağlamda (burada olduğu gibi) `TRUE`, bire dönüşür, yani bu Kasım veya Aralık ayındaki değil Ocak ayındaki tüm uçuşları bulur. Bu oldukça kafa karıştırıcı!

<!-- A useful short-hand for this problem is `x %in% y`. This will select every row where `x` is one of the values in `y`. We could use it to rewrite the code above: -->

Bu durum için yararlı bir kısa yol `x %in% y` komutudur. Bu `x` in `y` içerisinde yer aldığı tüm satırları seçer. Bunu yukarıdaki kodu tekrar yazmak için kullanabiliriz:

```{r, eval = FALSE}
nov_dec <- filter(flights, month %in% c(11, 12))
```

Sometimes you can simplify complicated subsetting by remembering De Morgan's law: `!(x & y)` is the same as `!x | !y`, and `!(x | y)` is the same as `!x & !y`. For example, if you wanted to find flights that weren't delayed (on arrival or departure) by more than two hours, you could use either of the following two filters:

<!-- Bazen karmaşık bir altküme operasyonunu De Morgan kuralını hatırlayarak basitleştirebilirsiniz: `!(x & y)` ile `!x | !y` aynıdır, ve `!(x | y)` ile `!x & !y` aynıdır. Örneğin, iki saatten fazla gecikmeli (varışta veya kalkışta) olmayan uçuşlar bulmak istiyorsanız, aşağıdaki iki filtreden birini kullanabilirsiniz: -->

```{r, eval = FALSE}
filter(flights, !(arr_delay > 120 | dep_delay > 120))
filter(flights, arr_delay <= 120, dep_delay <= 120)
```

<!-- As well as `&` and `|`, R also has `&&` and `||`. Don't use them here! You'll learn when you should use them in [conditional execution]. -->

`&` ve `|` yanı sıra, R'da ayrıca `&&` ve `||` vardır. Onları burada kullanmayın! Bunları ne zaman kullanmanız gerektiğini  [conditional execution]'de öğreneceksiniz.

<!-- Whenever you start using complicated, multipart expressions in `filter()`, consider making them explicit variables instead. That makes it much easier to check your work. You'll learn how to create new variables shortly. -->

`filter()` içinde karmaşık, çok parçalı ifadeler kullanmaya başladığınızda, bunları açık değişkenler haline getirmeyi düşünün. Bu, çalışmanızı kontrol etmeyi çok daha kolay hale getirir. Kısa süre içinde yeni değişkenlerin nasıl oluşturulacağını öğreneceksiniz.

<!-- ### Missing values -->

### Eksik değerler

<!-- One important feature of R that can make comparison tricky are missing values, or `NA`s ("not availables"). `NA` represents an unknown value so missing values are "contagious": almost any operation involving an unknown value will also be unknown. -->

R'nin karşılaştırmayı zorlaştırabilen önemli bir özelliği eksik değerler veya `NA`'lar ("mevcut değil"). `NA` bilinmeyen bir değeri temsil eder, bu nedenle eksik değerler "bulaşıcı"dır: bilinmeyen bir değeri içeren hemen hemen her işlem de bilinmeyecektir.

```{r}
NA > 5
10 == NA
NA + 10
NA / 2
```

<!-- The most confusing result is this one: -->

En kafa karıştırıcı sonuç şudur:

```{r}
NA == NA
```

<!-- It's easiest to understand why this is true with a bit more context: -->

Bunun neden daha doğru olduğunu biraz daha bağlamla anlamak en kolayı:

```{r}
# x, Mary'nin yaşı olsun. Kaç yaşında olduğunu bilmiyoruz.
x <- NA

# y, John'un yaşı olsun. Kaç yaşında olduğunu bilmiyoruz.
y <- NA

# John ve Mary aynı yaşta mı?
x == y
# Bilmiyoruz!
```

<!-- If you want to determine if a value is missing, use `is.na()`: -->

Bir değerin eksik olup olmadığını belirlemek istiyorsanız, `is.na()` kullanın:

```{r}
is.na(x)
```

`filter()` only includes rows where the condition is `TRUE`; it excludes both `FALSE` and `NA` values. If you want to preserve missing values, ask for them explicitly:

`filter()` yalnızca koşulun `TRUE` olduğu satırları içerir; hem `FALSE` hem de `NA` değerlerini çıkarır. Eksik değerleri korumak istiyorsanız, bunları açıkça isteyin:

```{r}
df <- tibble(x = c(1, NA, 3))
filter(df, x > 1)
filter(df, is.na(x) | x > 1)
```

<!-- ### Exercises -->

### Alıştırmalar

<!-- 1.  Find all flights that -->

<!--     1. Had an arrival delay of two or more hours -->
<!--     1. Flew to Houston (`IAH` or `HOU`) -->
<!--     1. Were operated by United, American, or Delta -->
<!--     1. Departed in summer (July, August, and September) -->
<!--     1. Arrived more than two hours late, but didn't leave late -->
<!--     1. Were delayed by at least an hour, but made up over 30 minutes in flight -->
<!--     1. Departed between midnight and 6am (inclusive) -->

<!-- 1.  Another useful dplyr filtering helper is `between()`. What does it do? -->
<!--     Can you use it to simplify the code needed to answer the previous  -->
<!--     challenges? -->

<!-- 1.  How many flights have a missing `dep_time`? What other variables are  -->
<!--     missing? What might these rows represent? -->

<!-- 1.  Why is `NA ^ 0` not missing? Why is `NA | TRUE` not missing? -->
<!--     Why is `FALSE & NA` not missing? Can you figure out the general -->
<!--     rule?  (`NA * 0` is a tricky counterexample!) -->
    
    
1.  Aşağıdaki koşulları sağlayan tüm uçuşları bulun

    1. İki veya daha fazla saatlik varış gecikmesi olan
    1. Houston'a uçan (`IAH` or `HOU`)
    1. United, American, veya Delta tarafından işletilen
    1. Yazın kalkan (Temmuz, Ağustos, ve Eylül)
    1. İki saatten fazla gecikmeyle gelen ancak gecikmesiz kalkan
    1. En az bir saat gecikmeli olan ancak 30 dakikadan fazlasını uçuşta telafi eden
    1. Gece yarısı ile 06:00 (dahil) arasında kalkan

1.  Bir diğer yararlı dplyr filtreleme yardımcısı da `between()`dir. Bu ne işe yarıyor?
    Önceki soruları yanıtlamak için gereken kodu basitleştirmek için kullanabilir misiniz?
    
1.  Kaç uçuşta "dep_time" eksik? Başka hangi değişkenler eksik? Bu satırlar neyi temsil ediyor olabilir?

1.  Neden `NA ^ 0` eksik değildir? Neden `NA | TRUE` eksik değildir? Neden `FALSE & NA` eksik değildir? Genel kuralı bulabilir misiniz? (`NA * 0` zorlu bir karşı örnek!)

<!-- ## Arrange rows with `arrange()` -->

## `arrange()` ile satırları düzenleme

<!-- `arrange()` works similarly to `filter()` except that instead of selecting rows, it changes their order. It takes a data frame and a set of column names (or more complicated expressions) to order by. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns: -->

`arrange()`, satırları seçmek yerine sıralarını değiştirmesi dışında `filter()` ile benzer şekilde çalışır. Bir veri tablosu ve sıralama için bir dizi sütun adı (veya daha karmaşık ifadeler) alır. Birden fazla sütun adı girerseniz, her bir ek sütun, önceki sütunların değerlerindeki eşit değerleri koparmak için kullanılır:

```{r}
arrange(flights, year, month, day)
```

<!-- Use `desc()` to re-order by a column in descending order: -->

Bir sütuna göre azalan sırada yeniden sıralamak için `desc()` kullanın:

```{r}
arrange(flights, desc(dep_delay))
```

<!-- Missing values are always sorted at the end: -->

Eksik değerler her zaman en sonda sıralanır:

```{r}
df <- tibble(x = c(5, 2, NA))
arrange(df, x)
arrange(df, desc(x))
```

<!-- ### Exercises -->

### Alıştırmalar

<!-- 1.  How could you use `arrange()` to sort all missing values to the start? -->
<!--     (Hint: use `is.na()`). -->

<!-- 1.  Sort `flights` to find the most delayed flights. Find the flights that -->
<!--     left earliest. -->

<!-- 1.  Sort `flights` to find the fastest flights. -->

<!-- 1.  Which flights travelled the longest? Which travelled the shortest? -->


1.  Tüm eksik değerleri başlangıca sıralamak için `arrange()`i nasıl kullanabilirsiniz? (İpucu: `is.na ()` kullanın).

1.  `flights`ı en gecikmeli uçuşları bulmak için sıralayın. En erken kalan uçuşları bulun.

1.  En hızlı uçuşları bulmak için `flights` sıralayın.

1.  Hangi uçuşlar en uzun seyahat etmiştir? Hangileri en kısa seyahat etmiştir?


<!-- ## Select columns with `select()` {#select} -->

## `select()` ile sütunları seçme {#select}

<!-- It's not uncommon to get datasets with hundreds or even thousands of variables. In this case, the first challenge is often narrowing in on the variables you're actually interested in. `select()` allows you to rapidly zoom in on a useful subset using operations based on the names of the variables. -->

Yüzlerce hatta binlerce değişken içeren veri kümeleri elde etmek nadir değildir. Bu durumda, ilk zorluk genellikle değişkenleri ilgilendiklerinize daraltmaktır. `select()`, değişkenlerin isimlerine dayalı işlemler kullanarak, yararlı bir altkümeye hızlı bir şekilde yakınlaşmanızı sağlar.

<!-- `select()` is not terribly useful with the flights data because we only have 19 variables, but you can still get the general idea: -->

`select()`, `flights` verisiyle çok kullanışlı değil çünkü yalnızca 19 değişkenimiz var, ancak yine de genel fikri edinebilirsiniz:

```{r}
# İsimle sütunları seçin
select(flights, year, month, day)
# Yıldan güne kadar (dahil) tüm sütunları seçin
select(flights, year:day)
# Yıldan güne kadar (dahil) olanlar hariç sütunları seçin
select(flights, -(year:day))
```

<!-- There are a number of helper functions you can use within `select()`: -->

<!-- * `starts_with("abc")`: matches names that begin with "abc". -->

<!-- * `ends_with("xyz")`: matches names that end with "xyz". -->

<!-- * `contains("ijk")`: matches names that contain "ijk". -->

<!-- * `matches("(.)\\1")`: selects variables that match a regular expression. -->
<!--    This one matches any variables that contain repeated characters. You'll  -->
<!--    learn more about regular expressions in [strings]. -->

<!-- *  `num_range("x", 1:3)`: matches `x1`, `x2` and `x3`. -->

`select()` içinde kullanabileceğiniz bir dizi yardımcı işlev vardır:

* `starts_with("abc")`: "abc" ile başlayan isimlerle eşleşir.

* `ends_with("xyz")`: "xyz" ile biten isimlerle eşleşir.

* `contains("ijk")`: "ijk" içeren isimlerle eşleşir.

* `matches("(.)\\1")`: kurallı ifadelerle (regular expression) eşleşen değişkenleri seçer. Bu, tekrarlanan karakterler içeren değişkenlerle eşleşir. [Strings] bölümünde düzenli ifadeler hakkında daha fazla bilgi edineceksiniz.
   
*  `num_range("x", 1:3)`: `x1`, `x2` ve `x3` ile eşleşir.
   
<!-- See `?select` for more details. -->

Detaylar için `?select`e bakın.

<!-- `select()` can be used to rename variables, but it's rarely useful because it drops all of the variables not explicitly mentioned. Instead, use `rename()`, which is a variant of `select()` that keeps all the variables that aren't explicitly mentioned: -->

`select()` değişkenleri yeniden isimlendirmek için kullanılabilir, ancak açıkça belirtilmeyen tüm değişkenleri dışarıda bıraktığı için nadiren kullanışlıdır. Bunun yerine, açıkça belirtilmeyen tüm değişkenleri koruyan `select()`in bir varyantı olan `rename()`i kullanın:

```{r}
rename(flights, tail_num = tailnum)
```

<!-- Another option is to use `select()` in conjunction with the `everything()` helper. This is useful if you have a handful of variables you'd like to move to the start of the data frame. -->

Bir diğer seçenek de `everything()` yardımcısı ile `select()`i kullanmaktır. Bu, veri çerçevesinin başlangıcına taşımak istediğiniz birkaç değişkeniniz olduğunda kullanışlıdır.

```{r}
select(flights, time_hour, air_time, everything())
```

<!-- ### Exercises -->

### Alıştırmalar

<!-- 1.  Brainstorm as many ways as possible to select `dep_time`, `dep_delay`, -->
<!--     `arr_time`, and `arr_delay` from `flights`. -->

<!-- 1.  What happens if you include the name of a variable multiple times in -->
<!--     a `select()` call? -->

<!-- 1.  What does the `one_of()` function do? Why might it be helpful in conjunction -->
<!--     with this vector? -->

<!--     ```{r} -->
<!--     vars <- c("year", "month", "day", "dep_delay", "arr_delay") -->
<!--     ``` -->

<!-- 1.  Does the result of running the following code surprise you?  How do the -->
<!--     select helpers deal with case by default? How can you change that default? -->

<!--     ```{r, eval = FALSE} -->
<!--     select(flights, contains("TIME")) -->
<!--     ``` -->

1.  `flights`tan `dep_time`, `dep_delay`, `arr_time`, ve `arr_delay`i seçmek için mümkün yolları bulmak için beyin fırtınası yapın.
    
1.  Bir değişkenin adını bir `select()` çağrısında birden çok kez eklerseniz ne olur?
  
1.  `one_of()` işlevi ne yapar? Bu vektörle birlikte yardımcı olma sebebi ne olabilir?
    
    ```{r}
    vars <- c("year", "month", "day", "dep_delay", "arr_delay")
    ```
    
1.  Aşağıdaki kodu çalıştırmanın sonucu sizi şaşırtıyor mu? Seçme yardımcıları varsayılan olarak büyük-küçük harf ile nasıl ilgilenir? Bu varsayılanı nasıl değiştirebilirsiniz?

    ```{r, eval = FALSE}
    select(flights, contains("TIME"))
    ```
    
<!-- ## Add new variables with `mutate()` -->

## `mutate()` ile yeni değişkenler ekleme

<!-- Besides selecting sets of existing columns, it's often useful to add new columns that are functions of existing columns. That's the job of `mutate()`.  -->

Mevcut sütun kümelerini seçmenin yanı sıra, mevcut sütunların işlevleri olan yeni sütunlar eklemek genellikle yararlıdır. Bu `mutate()` işidir.

<!-- `mutate()` always adds new columns at the end of your dataset so we'll start by creating a narrower dataset so we can see the new variables. Remember that when you're in RStudio, the easiest way to see all the columns is `View()`. -->

`mutate()` yeni sütunları her zaman verisetinizin sonuna ekler. Bu yüzden yeni değişkenleri görebilmemiz için daha dar bir veriseti oluşturarak başlayacağız. RStudio'dayken, tüm sütunları görmenin en kolay yolunun `View()` olduğunu unutmayın.

```{r}
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60
)
```

<!-- Note that you can refer to columns that you've just created: -->

Yeni oluşturduğunuz sütunları kullanabileceğinizi unutmayın:

```{r}
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

<!-- If you only want to keep the new variables, use `transmute()`: -->

Yalnızca yeni değişkenleri korumak istiyorsanız, `transmute()` kullanın:

```{r}
transmute(flights,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)
```

<!-- ### Useful creation functions {#mutate-funs} -->

### Yararlı oluşturma işlevleri {#mutate-funs}

<!-- There are many functions for creating new variables that you can use with `mutate()`. The key property is that the function must be vectorised: it must take a vector of values as input, return a vector with the same number of values as output. There's no way to list every possible function that you might use, but here's a selection of functions that are frequently useful: -->

Yeni değişkenler oluşturmak için `mutate()` ile kullanabileceğiniz birçok işlev vardır. Anahtar özelliği, işlevin vektörleştirilmesi gerektiğidir: girdi olarak bir değerler vektörü almalı, çıktı ile aynı sayıda değere sahip bir vektör oluşturmalıdır. Kullanabileceğiniz her olası işlevi listelemek mümkün değil, ancak burada sık kullanılan işlevlerin bir seçimi vardır:

<!-- *   Arithmetic operators: `+`, `-`, `*`, `/`, `^`. These are all vectorised, -->
<!--     using the so called "recycling rules". If one parameter is shorter than  -->
<!--     the other, it will be automatically extended to be the same length. This  -->
<!--     is most useful when one of the arguments is a single number: `air_time / 60`, -->
<!--     `hours * 60 + minute`, etc. -->

<!--     Arithmetic operators are also useful in conjunction with the aggregate -->
<!--     functions you'll learn about later. For example, `x / sum(x)` calculates  -->
<!--     the proportion of a total, and `y - mean(y)` computes the difference from  -->
<!--     the mean. -->
    
*   Aritmetik operatörler: `+`, `-`, `*`, `/`, `^`. Bunların hepsi "geri dönüşüm kuralları" kullanılarak vektörleştirilmiştir. Bir parametre diğerinden daha kısaysa, otomatik olarak aynı uzunlukta olacak şekilde genişletilir. Bu, bağımsız değişkenlerden biri tek bir sayı olduğunda yararlıdır: `air_time / 60`, `hours * 60 + minute`, etc.
    
    Aritmetik işleçler, daha sonra öğreneceğiniz yığın işlevleriyle birlikte de yararlıdır. Örneğin, `x / sum(x)` toplamın oranını hesaplar ve `y - mean(y)` ortalamadan farkı hesaplar.
    
<!-- *   Modular arithmetic: `%/%` (integer division) and `%%` (remainder), where -->
<!--     `x == y * (x %/% y) + (x %% y)`. Modular arithmetic is a handy tool because  -->
<!--     it allows you to break integers up into pieces. For example, in the  -->
<!--     flights dataset, you can compute `hour` and `minute` from `dep_time` with: -->
    
*   Modüler aritmetik: `x == y * (x %/% y) + (x %% y)` ifadesinde `%/%` (tamsayı bölümü) and `%%` (kalan). Modüler aritmetik kullanışlı bir araçtır, çünkü tam sayıları parçalara ayırmanıza izin verir. Örneğin, `flights` verisetinde `dep_time`dan `hour` (saat) ve `minute` (dakika) hesaplayabilirsiniz:
    
    ```{r}
    transmute(flights,
      dep_time,
      hour = dep_time %/% 100,
      minute = dep_time %% 100
    )
    ```
  
<!-- *   Logs: `log()`, `log2()`, `log10()`. Logarithms are an incredibly useful -->
<!--     transformation for dealing with data that ranges across multiple orders of -->
<!--     magnitude. They also convert multiplicative relationships to additive, a -->
<!--     feature we'll come back to in modelling. -->

<!--     All else being equal, I recommend using `log2()` because it's easy to -->
<!--     interpret: a difference of 1 on the log scale corresponds to doubling on -->
<!--     the original scale and a difference of -1 corresponds to halving. -->
    
*   Logaritmalar: `log()`, `log2()`, `log10()`. Logaritmalar, birden fazla büyüklük aralığında değişen verilerle uğraşmak için inanılmaz derecede faydalı bir dönüşümdür. Ayrıca, modellemede geri döneceğimiz bir özellik olan çarpımsal ilişkileri toplamlara dönüştürüyorlar.
    
    Diğer her şey sabit olduğunda, `log2()` kullanımını öneririm çünkü yorumlaması kolaydır: logaritmik ölçekteki 1lik bir fark orjinal ölçekte iki kat almaya denk gelir ve -1 yarıya inmeye denk gelir.

<!-- *   Offsets: `lead()` and `lag()` allow you to refer to leading or lagging  -->
<!--     values. This allows you to compute running differences (e.g. `x - lag(x)`)  -->
<!--     or find when values change (`x != lag(x)`). They are most useful in  -->
<!--     conjunction with `group_by()`, which you'll learn about shortly. -->

*   Kaydırmalar: `lead()` ve `lag()` önde gelen veya geciken değerleri kullanmanıza olanak tanır. Bu vektörlerdeki ardaşık değerler arasındaki farkları hesaplamanıza (örn. `x - lag(x)`) ya da değerlerin ne zaman değiştiğini bulmanıza (`x != lag(x)`) olanak tanır. Kısa sürede öğreneceğiniz `group_by()` ile birlikte kullanıldıklarında en yararlıdırlar.
    
    ```{r}
    (x <- 1:10)
    lag(x)
    lead(x)
    ```
  
<!-- *   Cumulative and rolling aggregates: R provides functions for running sums, -->
<!--     products, mins and maxes: `cumsum()`, `cumprod()`, `cummin()`, `cummax()`;  -->
<!--     and dplyr provides `cummean()` for cumulative means. If you need rolling -->
<!--     aggregates (i.e. a sum computed over a rolling window), try the RcppRoll -->
<!--     package. -->
    
*   Kümülatif ve yuvarlanan yığın işlevleri: R, kümülatif toplamlar, çarpımlar, minimum ve maksimumlar için işlevler sağlar: `cumsum()`, `cumprod()`, `cummin()`, `cummax()`; ve dplyr birikimli ortalama için `cummean()` işlevini sağlar. Yuvarlanan birleştirmelere (yani, yuvarlanan bir pencerede hesaplanan bir işlev) ihtiyacınız varsa, RcppRoll paketini deneyin.
    
    ```{r}
    x
    cumsum(x)
    cummean(x)
    ```

<!-- *   Logical comparisons, `<`, `<=`, `>`, `>=`, `!=`, and `==`, which you learned about -->
<!--     earlier. If you're doing a complex sequence of logical operations it's  -->
<!--     often a good idea to store the interim values in new variables so you can -->
<!--     check that each step is working as expected. -->
    
*   Daha önceden öğrendiğiniz mantıksal karşılaştırmalar, `<`, `<=`, `>`, `>=`, `!=`, ve `==`. Karmaşık bir mantıksal işlem dizisi yapıyorsanız, ara değerlerin yeni değişkenlerde saklanması genellikle iyi bir fikirdir, böylece her adımın beklendiği gibi çalışıp çalışmadığını kontrol edebilirsiniz.

*   Ranking: there are a number of ranking functions, but you should 
    start with `min_rank()`. It does the most usual type of ranking 
    (e.g. 1st, 2nd, 2nd, 4th). The default gives smallest values the small
    ranks; use `desc(x)` to give the largest values the smallest ranks. 
    
*   Sıralama: birden fazla sıralama işlevi vardır, ancak `min_rank()` ile başlamalısınız. En genel sıralama türünü yapar (örneğin 1., 2., 2., 4.). Varsayılan olarak en küçük değerlere küçük sıralar verir; en büyük değerlere en küçük değerleri vermek için `desc(x)` kullanın.

    ```{r}
    y <- c(1, 2, 2, NA, 3, 4)
    min_rank(y)
    min_rank(desc(y))
    ```
    
<!-- If `min_rank()` doesn't do what you need, look at the variants -->
<!-- `row_number()`, `dense_rank()`, `percent_rank()`, `cume_dist()`, -->
<!-- `ntile()`.  See their help pages for more details. -->
    
    Eğer `min_rank()` ihtiyacınız olanı yapmazsa, varyantları olan `row_number()`, `dense_rank()`, `percent_rank()`, `cume_dist()`, `ntile()`a bakın. Detaylar için yardım sayfalarına bakın.
    
    ```{r}
    row_number(y)
    dense_rank(y)
    percent_rank(y)
    cume_dist(y)
    ```

<!-- ### Exercises -->

### Alıştırmalar

```{r, eval = FALSE, echo = FALSE}
flights <- flights %>% mutate(
  dep_time = hour * 60 + minute,
  arr_time = (arr_time %/% 100) * 60 + (arr_time %% 100),
  airtime2 = arr_time - dep_time,
  dep_sched = dep_time + dep_delay
)

ggplot(flights, aes(dep_sched)) + geom_histogram(binwidth = 60)
ggplot(flights, aes(dep_sched %% 60)) + geom_histogram(binwidth = 1)
ggplot(flights, aes(air_time - airtime2)) + geom_histogram()
```

<!-- 1.  Currently `dep_time` and `sched_dep_time` are convenient to look at, but -->
<!--     hard to compute with because they're not really continuous numbers.  -->
<!--     Convert them to a more convenient representation of number of minutes -->
<!--     since midnight. -->
    
1. Şu anda `dep_time` ve `sched_dep_time` değerlerine bakmak uygundur, ancak gerçekten sürekli sayılar olmadıkları için hesaplama için kullanılması zordur. Gece yarısından bu yana geçen dakikaya karşılık gelecek daha uygun bir gösterimine dönüştürün.
    
<!-- 1.  Compare `air_time` with `arr_time - dep_time`. What do you expect to see? -->
<!--     What do you see? What do you need to do to fix it? -->
    
1.  `air_time` ı `arr_time - dep_time` ile karşılaştırın. Ne görmeyi umuyorsununz? Ne görüyorsunuz? Düzeltmek için ne yapmanız gerekiyor?
    
<!-- 1.  Compare `dep_time`, `sched_dep_time`, and `dep_delay`. How would you -->
<!--     expect those three numbers to be related? -->

1.  `dep_time`, `sched_dep_time`, ve `dep_delay`ı karşılaştırın. Bu üç sayının birbiriyle nasıl ilişkili olmasını beklersiniz?

<!-- 1.  Find the 10 most delayed flights using a ranking function. How do you want  -->
<!--     to handle ties? Carefully read the documentation for `min_rank()`. -->
    
1.  Bir sıralama fonksiyonu kullanarak en çok geciken 10 uçuşu bulun. Aynı değeri olanları nasıl ele almak istiyorsun? `min_rank()` dökümantasyonunu dikkatlice okuyun.

<!-- 1.  What does `1:3 + 1:10` return? Why? -->

1.  `1:3 + 1:10` ne sonuç verir? neden?

<!-- 1.  What trigonometric functions does R provide? -->

1. R hangi trigonometrik fonksiyonları sağlar?

<!-- ## Grouped summaries with `summarise()` -->

## `summarise()` ile gruplandırılmış özetler

The last key verb is `summarise()`. It collapses a data frame to a single row:

Son anahtar fiil `summarise()`.Bir veri tablosunu tek bir satıra daraltır:

```{r}
summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
```

<!-- (We'll come back to what that `na.rm = TRUE` means very shortly.) -->

(`na.rm = TRUE` ifadesinin ne anlama geldiğine çok kısa sürede geri döneceğiz.)

<!-- `summarise()` is not terribly useful unless we pair it with `group_by()`. This changes the unit of analysis from the complete dataset to individual groups. Then, when you use the dplyr verbs on a grouped data frame they'll be automatically applied "by group". For example, if we applied exactly the same code to a data frame grouped by date, we get the average delay per date: -->

`summarise()`, `group_by()` ile eşleştirmediğimiz sürece çok yararlı değildir. Bu, analiz birimini tüm verisetinden tek tek gruplara değiştirir. Ardından, gruplanmış bir veri çerçevesinde dplyr fiillerini kullandığınızda, bunlar otomatik olarak "gruba göre" uygulanır. Örneğin, tarihe göre gruplandırılmış bir veri çerçevesine aynı kodu uygularsak, tarih başına ortalama gecikmeyi alırız:

```{r}
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))
```

<!-- Together `group_by()` and `summarise()` provide one of the tools that you'll use most commonly when working with dplyr: grouped summaries. But before we go any further with this, we need to introduce a powerful new idea: the pipe. -->

`group_by()` ve `summarise()` birlikte, dplyr ile çalışırken en sık kullanacağınız araçlardan birini sağlar:  gruplandırılmış özetler. Ancak bu konuda daha ileri gitmeden önce, güçlü yeni bir fikir sunmamız gerekiyor: pipe operatörü.

<!-- ### Combining multiple operations with the pipe -->

### Pipe ile birden fazla işlemi birleştirmek

<!-- Imagine that we want to explore the relationship between the distance and average delay for each location. Using what you know about dplyr, you might write code like this: -->

Her bir konum için mesafe ve ortalama gecikme arasındaki ilişkiyi keşfetmek istediğimizi düşünün. Dplyrda bildiklerinizi kullanarak, şöyle bir kod yazabilirsiniz:

```{r, fig.width = 6}
by_dest <- group_by(flights, dest)
delay <- summarise(by_dest,
  count = n(),
  dist = mean(distance, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE)
)
delay <- filter(delay, count > 20, dest != "HNL")

# Görünüşe göre gecikmeler ~ 750 mil mesafeye kadar artıyor ve 
# sonra azalıyor. Belki uçuşlar uzadıkça havada gecikmeleri 
# telafi etme yeteneği daha fazladır?
ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
  geom_point(aes(size = count), alpha = 1/3) +
  geom_smooth(se = FALSE)
```

<!-- There are three steps to prepare this data: -->

Bu verileri hazırlamak için üç adım vardır:

<!-- 1.  Group flights by destination. -->

1.  Uçuşları varış noktasına göre gruplandırın.

<!-- 1.  Summarise to compute distance, average delay, and number of flights. -->

1.  Mesafe, ortalama gecikme ve uçuş sayısını hesaplamak için özetleyin.

<!-- 1.  Filter to remove noisy points and Honolulu airport, which is almost -->
<!--     twice as far away as the next closest airport. -->
    
1.  Gürültülü noktaları ve bir sonraki en yakın havaalanına neredeyse iki kat daha uzak olan Honolulu havaalanını kaldırmak için filtreleyin.

<!-- This code is a little frustrating to write because we have to give each intermediate data frame a name, even though we don't care about it. Naming things is hard, so this slows down our analysis.  -->

Bu kodun yazılması biraz sinir bozucu, çünkü umursamasak da her ara veri tablosuna bir isim vermemiz gerekiyor. Bir şeyleri isimlendirmek zor, bu da analizlerimizi yavaşlatıyor.

There's another way to tackle the same problem with the pipe, `%>%`:

Pipe operatörü (`%>%`) ile aynı problemi çözmenin başka bir yolu var:

```{r}
delays <- flights %>% 
  group_by(dest) %>% 
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>% 
  filter(count > 20, dest != "HNL")
```

This focuses on the transformations, not what's being transformed, which makes the code easier to read. You can read it as a series of imperative statements: group, then summarise, then filter. As suggested by this reading, a good way to pronounce `%>%` when reading code is "then".

Bu dönüştürülene değil dönüşümlere odaklanarak kodun daha kolay okunmasını sağlar. Bunu bir dizi emir kipinde ifade olarak okuyabilirsiniz: gruplandır, sonra özetle, sonra filtrele. Bu okumadan da çıkarıldığı gibi, `%>%` operatörünü okumanın güzel bir yolu, "sonra"dır. 

<!-- Behind the scenes, `x %>% f(y)` turns into `f(x, y)`, and `x %>% f(y) %>% g(z)` turns into `g(f(x, y), z)` and so on. You can use the pipe to rewrite multiple operations in a way that you can read left-to-right, top-to-bottom. We'll use piping frequently from now on because it considerably improves the readability of code, and we'll come back to it in more detail in [pipes]. -->

Arkaplanda `x %>% f(y)` ifadesi `f(x, y)`a, `x %>% f(y) %>% g(z)` ifadesi `g(f(x, y), z)`a dönüşür ve bunun gibi devam eder. Pipe operatörünü birçok işlemi soldan sağa okuyacağınız şekilde yukarıdan aşağıya yazabilirsiniz.eceğiniz şekilde yeniden yazmak için boruyu kullanabilirsiniz. Bundan sonra boruları sık sık kullanacağız, çünkü kodun okunabilirliğini önemli ölçüde artırıyor ve [pipes]'da daha ayrıntılı olarak buna geri döneceğiz.

<!-- Working with the pipe is one of the key criteria for belonging to the tidyverse. The only exception is ggplot2: it was written before the pipe was discovered. Unfortunately, the next iteration of ggplot2, ggvis, which does use the pipe, isn't quite ready for prime time yet.  -->

Pipe operatörü ile çalışmak tidyverse'e aitlik için anahtar kriterlerden biridir. Tek istisna ggplot2'dir: çünkü pipe operatörünün keşfinden önce yazılmıştı. Ne yazık ki, ggplot2 nin bir sonraki sürümü olan ve pipe operatörünü kullanan ggvis henüz başlatılmaya hazır değil.

<!-- ### Missing values -->

### Eksik değerler

<!-- You may have wondered about the `na.rm` argument we used above. What happens if we don't set it? -->

Yukarıda kullandığımız `na.rm` argümanını merak etmiş olabilirsiniz. Onu kullanmazsak ne olur?

```{r}
flights %>% 
  group_by(year, month, day) %>% 
  summarise(mean = mean(dep_delay))
```

<!-- We get a lot of missing values! That's because aggregation functions obey the usual rule of missing values: if there's any missing value in the input, the output will be a missing value. Fortunately, all aggregation functions have an `na.rm` argument which removes the missing values prior to computation: -->

Çok fazla sayıda eksik değer alırız! Bunun sebebi yığın fonksiyonlarının eksik değerlerin genel kuralına uymasıdır: eğer girdide eksik değer varsa, çıktı da eksik değer olur. Şanslıyız ki, tüm birleştirme fonksiyonları hesaplamadan önce eksik değerleri eleyen `na.rm` argümanına sahiptir.

```{r}
flights %>% 
  group_by(year, month, day) %>% 
  summarise(mean = mean(dep_delay, na.rm = TRUE))
```

<!-- In this case, where missing values represent cancelled flights, we could also tackle the problem by first removing the cancelled flights. We'll save this dataset so we can reuse it in the next few examples. -->

Eksik değerlerin iptal edilen uçuşları temsil ettiği bu durumda, öncelikle iptal edilen uçuşları kaldırarak da sorunu çözebiliriz. Bu verisetini sonraki birkaç örnekte tekrar kullanabilmek için kaydedeceğiz.

```{r}
not_cancelled <- flights %>% 
  filter(!is.na(dep_delay), !is.na(arr_delay))

not_cancelled %>% 
  group_by(year, month, day) %>% 
  summarise(mean = mean(dep_delay))
```

<!-- ### Counts -->

### Sayımlar

<!-- Whenever you do any aggregation, it's always a good idea to include either a count (`n()`), or a count of non-missing values (`sum(!is.na(x))`). That way you can check that you're not drawing conclusions based on very small amounts of data. For example, let's look at the planes (identified by their tail number) that have the highest average delays: -->

Herhangi bir yığın işlemi yaptığınızda, bir sayım (`n()`) veya eksik olmayan değerlerin sayımını (`sum(!is.na(x))`) eklemek her zaman iyi bir fikirdir. Bu şekilde, çok az miktarda verilere dayanarak sonuç çıkarmadığınızı kontrol edebilirsiniz. Örneğin, en yüksek ortalama gecikmelere sahip olan uçaklara (kuyruk numaralarıyla tanımlanan) bakalım:

```{r}
delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay)
  )

ggplot(data = delays, mapping = aes(x = delay)) + 
  geom_freqpoly(binwidth = 10)
```

<!-- Wow, there are some planes that have an _average_ delay of 5 hours (300 minutes)! -->

Wow, __ortalama__ gecikmesi 5 saat (300 dakika) olan uçaklar var! 

<!-- The story is actually a little more nuanced. We can get more insight if we draw a scatterplot of number of flights vs. average delay: -->

Hikayede aslında biraz daha nüans var. Ortalama gecikmeye karşı uçuş sayısının dağılım grafiğini çizersek daha fazla bilgi edinebiliriz:

```{r}
delays <- not_cancelled %>% 
  group_by(tailnum) %>% 
  summarise(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(data = delays, mapping = aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)
```

<!-- Not surprisingly, there is much greater variation in the average delay when there are few flights. The shape of this plot is very characteristic: whenever you plot a mean (or other summary) vs. group size, you'll see that the variation decreases as the sample size increases. -->

Şaşırtıcı olmayan bir şekilde, az sayıda uçuş olduğunda ortalama gecikmede çok daha fazla değişiklik var. Bu grafiğin şekli çok karakteristiktir: ortalamayı (veya başka bir özeti) grup boyutuna karşı çizdiğinizde, örnek boyutu arttıkça varyasyonun azaldığını görürsünüz.

<!-- When looking at this sort of plot, it's often useful to filter out the groups with the smallest numbers of observations, so you can see more of the pattern and less of the extreme variation in the smallest groups. This is what the following code does, as well as showing you a handy pattern for integrating ggplot2 into dplyr flows. It's a bit painful that you have to switch from `%>%` to `+`, but once you get the hang of it, it's quite convenient. -->

Bu tür bir figüre bakarken, en az sayıda gözlem içeren grupları filtrelemek genellikle yararlıdır, böylece en küçük gruplarda daha fazla örüntü ve daha az ekstrem varyasyon görebilirsiniz. Aşağıdaki kod ggplot2 ve dplyr akışını entegre etmek için kullanışlı bir örüntü göstermenin yanı sıra bunu gerçekleştirir. `%>%`dan `+`ya geçiş biraz acı verici, ancak bir kez kavradıktan sonra oldukça uygun.

```{r}
delays %>% 
  filter(n > 25) %>% 
  ggplot(mapping = aes(x = n, y = delay)) + 
    geom_point(alpha = 1/10)
```

--------------------------------------------------------------------------------

<!-- RStudio tip: a useful keyboard shortcut is Cmd/Ctrl + Shift + P. This resends the previously sent chunk from the editor to the console. This is very convenient when you're (e.g.) exploring the value of `n` in the example above. You send the whole block once with Cmd/Ctrl + Enter, then you modify the value of `n` and press Cmd/Ctrl + Shift + P to resend the complete block. -->

RStudio püf noktası: kullanışlı bir klavye kısayolu Cmd / Ctrl + Shift + P'dir. Bu, önceden gönderilen parçayı düzenleyiciden konsola yeniden gönderir. Yukarıdaki örnekte `n` değerini incelediğinizde (örneğin) çok kullanışlıdır. Tüm bloğu bir kez Cmd / Ctrl + Enter ile gönderebilir, ardından `n` değerini değiştirip ve tüm bloğu yeniden göndermek için Cmd / Ctrl + Shift + P tuşlarına basabilirsiniz.

--------------------------------------------------------------------------------

<!-- There's another common variation of this type of pattern. Let's look at how the average performance of batters in baseball is related to the number of times they're at bat. Here I use data from the __Lahman__ package to compute the batting average (number of hits / number of attempts) of every major league baseball player.   -->

Bu tip örüntünün bir çeşidi daha var. Beyzboldaki vurucuların ortalama performansının vuruş sayısı ile nasıl ilişkili olduğuna bakalım. Burada her ana lig beyzbol oyuncusunun vuruş ortalamasını (isabet sayısı / deneme sayısı) hesaplamak için  __Lahman__ paketindeki verileri kullanıyorum.

<!-- When I plot the skill of the batter (measured by the batting average, `ba`) against the number of opportunities to hit the ball (measured by at bat, `ab`), you see two patterns: -->

Vurucu yeteneğini (vuruş ortalaması,`ba` ile ölçülen) topa vurmak için yakalanan fırsat sayısına (vuruş sayısı, `ab` ile ölçülen) göre çizdiğimde, iki desen görürsünüz:

<!-- 1.  As above, the variation in our aggregate decreases as we get more  -->
<!--     data points. -->

<!-- 2.  There's a positive correlation between skill (`ba`) and opportunities to  -->
<!--     hit the ball (`ab`). This is because teams control who gets to play,  -->
<!--     and obviously they'll pick their best players. -->

1.  Yukarıdaki gibi, daha fazla veri noktası elde ettikçe yığın işlemindeki değişiklik azalır.

2.  Beceri (`ba`) ve topa vurma fırsatları (`ab`) arasında pozitif korelasyon vardır. Bunun sebebi takımların kimin oynayacağını kontrol etmesi ve belli ki en iyi oyuncularını seçmeleridir.

```{r}
# Tibble'a çevirin ki güzel yazdırılsın
batting <- as_tibble(Lahman::Batting)

batters <- batting %>% 
  group_by(playerID) %>% 
  summarise(
    ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    ab = sum(AB, na.rm = TRUE)
  )

batters %>% 
  filter(ab > 100) %>% 
  ggplot(mapping = aes(x = ab, y = ba)) +
    geom_point() + 
    geom_smooth(se = FALSE)
```

<!-- This also has important implications for ranking. If you naively sort on `desc(ba)`, the people with the best batting averages are clearly lucky, not skilled: -->

Bunun sıralama için de önemli etkileri vardır. Naif bir şekilde azalan beceriye (`desc(ba)`) göre sıralarsanız, en iyi vuruş ortalamalarına sahip insanlar açıkça şanslıdır, yetenekli değildir:

```{r}
batters %>% 
  arrange(desc(ba))
```

<!-- You can find a good explanation of this problem at <http://varianceexplained.org/r/empirical_bayes_baseball/> and <http://www.evanmiller.org/how-not-to-sort-by-average-rating.html>. -->

Bu problemın güzel bir açıklamasını <http://varianceexplained.org/r/empirical_bayes_baseball/> ve <http://www.evanmiller.org/how-not-to-sort-by-average-rating.html> adreslerinde bulabilirsiniz.

<!-- ### Useful summary functions {#summarise-funs} -->

### Yararlı özet fonksiyonları {#summarise-funs}

<!-- Just using means, counts, and sum can get you a long way, but R provides many other useful summary functions: -->

Sadece ortalamaları, sayımları ve toplamı kullanmak yol katetmenizi sağlayabilir, ancak R diğer birçok yararlı özet işlevi sağlar:

<!-- *   Measures of location: we've used `mean(x)`, but `median(x)` is also -->
<!--     useful. The mean is the sum divided by the length; the median is a value  -->
<!--     where 50% of `x` is above it, and 50% is below it. -->

<!--     It's sometimes useful to combine aggregation with logical subsetting.  -->
<!--     We haven't talked about this sort of subsetting yet, but you'll learn more -->
<!--     about it in [subsetting]. -->
    
*   Konum ölçüleri: `mean(x)` kullandık, ama `median(x)` da yararlıdır. Ortalama (mean) toplamın uzunluğa (length) bölümüdür; medyan (median) ise `x` değerlerinin %50sinin daha yüksek, %50sininse daha düşük olduğu değerdir.
    
    Bazen, yığın işlemlerini mantıksal altkümeleme işlemleri ile kullanmak yararlıdır. Bu çeşit kümelemeden henüz bahsetmedik, ancak [altkümeleme]de daha fazlasını öğreneceksiniz.
    
    ```{r}
    not_cancelled %>% 
      group_by(year, month, day) %>% 
      summarise(
        avg_delay1 = mean(arr_delay),
        avg_delay2 = mean(arr_delay[arr_delay > 0]) # the average positive delay
      )
    ```


<!-- *   Measures of spread: `sd(x)`, `IQR(x)`, `mad(x)`. The root mean squared deviation, -->
<!--     or standard deviation `sd(x)`, is the standard measure of spread. -->
<!--     The interquartile range `IQR(x)` and median absolute deviation `mad(x)` -->
<!--     are robust equivalents that may be more useful if you have outliers. -->
    
*   Yayılım ölçüleri: `sd(x)`, `IQR(x)`, `mad(x)`. Kök-ortalama-kare-sapma, ya da standart sapma, `sd(x)`, yayılımın standart ölçüsüdür. Çeyrekler arası açıklık, `IQR(x)`, ve ortalama mutlak sapma, `mad(x)`, dirençli (robust) eşdeğerlerdir ve aykırı değerler (outlier) bulunması durumunda daha kullanışlı olabilir.
    
    ```{r}
    # Why is distance to some destinations more variable than to others?
    not_cancelled %>% 
      group_by(dest) %>% 
      summarise(distance_sd = sd(distance)) %>% 
      arrange(desc(distance_sd))
    ```
  
<!-- *   Measures of rank: `min(x)`, `quantile(x, 0.25)`, `max(x)`. Quantiles -->
<!--     are a generalisation of the median. For example, `quantile(x, 0.25)` -->
<!--     will find a value of `x` that is greater than 25% of the values, -->
<!--     and less than the remaining 75%. -->

*   Sıra ölçüleri: `min(x)`, `quantile(x, 0.25)`, `max(x)`. Kantiller medyanın genelleştirilmesidir. Örneğin, `quantile(x, 0.25)` değerlerin %25inden daha yüksek, %75inden daha düşük olan `x` değerini bulur.

    ```{r}
    # When do the first and last flights leave each day?
    not_cancelled %>% 
      group_by(year, month, day) %>% 
      summarise(
        first = min(dep_time),
        last = max(dep_time)
      )
    ```
  
<!-- *   Measures of position: `first(x)`, `nth(x, 2)`, `last(x)`. These work  -->
<!--     similarly to `x[1]`, `x[2]`, and `x[length(x)]` but let you set a default  -->
<!--     value if that position does not exist (i.e. you're trying to get the 3rd -->
<!--     element from a group that only has two elements). For example, we can -->
<!--     find the first and last departure for each day: -->

*   Pozisyon ölçüleri: `first(x)`, `nth(x, 2)`, `last(x)`. Bunlar `x[1]`, `x[2]`, ve `x[length(x)]`e benzer çalışır, ancak eğer o pozisyon mevcut değilse varsayılan bir değer belirlemeyi sağlar (yani 2 elemanı bulunan bir gruptan 3.elemanı almaya çalışırsanız). Örneğin, her günün ilk ve son kalkışını bulabiliriz:
    
    ```{r}
    not_cancelled %>% 
      group_by(year, month, day) %>% 
      summarise(
        first_dep = first(dep_time), 
        last_dep = last(dep_time)
      )
    ```
    
    <!-- These functions are complementary to filtering on ranks. Filtering gives -->
    <!-- you all variables, with each observation in a separate row: -->
    
    Bu işlevler, sıralamaların filtrelenmesine tamamlayıcı niteliktedir. 
    Filtreleme, tüm gözlemler ayrı bir satırda olacak şekilde tüm değişkenleri 
    verir:
    
    ```{r}
    not_cancelled %>% 
      group_by(year, month, day) %>% 
      mutate(r = min_rank(desc(dep_time))) %>% 
      filter(r %in% range(r))
    ```

<!-- *   Counts: You've seen `n()`, which takes no arguments, and returns the  -->
<!--     size of the current group. To count the number of non-missing values, use -->
<!--     `sum(!is.na(x))`. To count the number of distinct (unique) values, use -->
<!--     `n_distinct(x)`. -->

*   Sayımlar: Argüman almayan grubun büyüklüğünü veren `n()`i daha önceden gördünüz. Eksik olmayan değerlerin sayı için, `sum(!is.na(x))` kullanın. Birbirinden farklı (biricik) değerlerin sayısı için, `n_distinct(x)` kullanın. 
    
    ```{r}
    # Which destinations have the most carriers?
    not_cancelled %>% 
      group_by(dest) %>% 
      summarise(carriers = n_distinct(carrier)) %>% 
      arrange(desc(carriers))
    ```
    
    <!-- Counts are so useful that dplyr provides a simple helper if all you want is  -->
    <!-- a count: -->
    
    Sayımlar o kadar kullanışlıdır ki, istediğiniz tek şey bir sayımsa dplyr basit bir yardımcı sağlar:
    
    ```{r}
    not_cancelled %>% 
      count(dest)
    ```
    
    <!-- You can optionally provide a weight variable. For example, you could use  -->
    <!-- this to "count" (sum) the total number of miles a plane flew: -->
    
    İsteğe bağlı olarak bir ağırlık değişkeni sağlayabilirsiniz. Örneğin, bunu bir uçağın uçtuğu toplam mil sayısını "saymak" (toplamak) için kullanabilirsiniz:
    
    ```{r}
    not_cancelled %>% 
      count(tailnum, wt = distance)
    ```

<!-- *   Counts and proportions of logical values: `sum(x > 10)`, `mean(y == 0)`. -->
<!--     When used with numeric functions, `TRUE` is converted to 1 and `FALSE` to 0.  -->
<!--     This makes `sum()` and `mean()` very useful: `sum(x)` gives the number of  -->
<!--     `TRUE`s in `x`, and `mean(x)` gives the proportion. -->

*   Mantıksal değerlerin sayı ve oranları: `sum(x > 10)`, `mean(y == 0)`. Numerik fonksiyonlarla birlikte kullanıldığında, `TRUE` 1e ve `FALSE` 0a dönüştürülür. Bu da `sum()` ve `mean()`i çok kullanışlı kılar: `sum(x)` toplam `TRUE` sayısını, ve `mean(x)` oranını verir. 
    
    ```{r}
    # Sabah 5'ten önce kaç uçuş kalktı? (bunlar genellikle bir önceki günün 
    # gecikmeli uçuşlarını gösterir)
    not_cancelled %>% 
      group_by(year, month, day) %>% 
      summarise(n_early = sum(dep_time < 500))
    
    # Uçuşların yüzde kaçı bir saatten fazla gecikiyor?
    not_cancelled %>% 
      group_by(year, month, day) %>% 
      summarise(hour_perc = mean(arr_delay > 60))
    ```

<!-- ### Grouping by multiple variables -->

### Birden fazla değişken ile gruplama

<!-- When you group by multiple variables, each summary peels off one level of the grouping. That makes it easy to progressively roll up a dataset: -->

Birden çok değişkene göre gruplandırdığınızda, her özet gruplamanın bir düzeyini oluşturur. Bu, bir veri kümesini aşamalı olarak toparlanmasını kolaylaştırır:

```{r}
daily <- group_by(flights, year, month, day)
(per_day   <- summarise(daily, flights = n()))
(per_month <- summarise(per_day, flights = sum(flights)))
(per_year  <- summarise(per_month, flights = sum(flights)))
```

<!-- Be careful when progressively rolling up summaries: it's OK for sums and counts, but you need to think about weighting means and variances, and it's not possible to do it exactly for rank-based statistics like the median. In other words, the sum of groupwise sums is the overall sum, but the median of groupwise medians is not the overall median. -->

Özetleri aşamalı olarak toplarken dikkatli olun: toplamlar ve sayımlar için sorun değil, ancak ağırlıklı ortalamalar ve varyanslar için düşünmeniz gerekir ve bunu medyan gibi sıra tabanlı istatistikler için tam olarak yapmak mümkün değildir. Başka bir deyişle, grupsal toplamların toplamı genel toplamdır, ancak grupsal medyanların medyanı genel medyan değildir.

<!-- ### Ungrouping -->

### Grupların bozulması

<!-- If you need to remove grouping, and return to operations on ungrouped data, use `ungroup()`.  -->

Gruplamayı bozmanız ve grupsuz veride işlevler çalıştırmanız gerekirse, `ungroup()` kullanın. 

```{r}
daily %>% 
  ungroup() %>%             # artık tarihle gruplu değil
  summarise(flights = n())  # tüm uçuşlar
```

<!-- ### Exercises -->

### Alıştırmalar

<!-- 1.  Brainstorm at least 5 different ways to assess the typical delay  -->
<!--     characteristics of a group of flights. Consider the following scenarios: -->
    
1.  Bir grup uçuşun tipik gecikmesini değerlendirmek için en az 5 değişik yöntem bulun. Şu senaryoları düşünün:
    
    <!-- * A flight is 15 minutes early 50% of the time, and 15 minutes late 50% of  -->
    <!--   the time. -->
      
    * Bir uçuş uçuşlarının %50sinde 15 dakika erken, ve %50sinde 15 dakika geç.
      
    <!-- * A flight is always 10 minutes late. -->
    
    * Hep 10 dakika geç kalan bir uçuş

    <!-- * A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of  -->
    <!--   the time. -->
      
    * Bir uçuş, tüm uçuşlarının %50sinde 30 dakika erken, %50sinde 30 dakika geç.
      
    <!-- * 99% of the time a flight is on time. 1% of the time it's 2 hours late. -->
    
    * Uçuşların %99unda zamanında olan, %1inde 2 saat geç kalan bir uçuş.
    
    <!-- Which is more important: arrival delay or departure delay? -->
    
    Hangisi daha önemlidir: varış gecikmesi mi yoksa kalkış gecikmesi mi?

<!-- 1.  Come up with another approach that will give you the same output as  -->
<!--     `not_cancelled %>% count(dest)` and  -->
<!--     `not_cancelled %>% count(tailnum, wt = distance)` (without using  -->
<!--     `count()`). -->
    
1.  `not_cancelled %>% count(dest)` ve `not_cancelled %>% count(tailnum, wt = distance)` ile aynı sonucu verecek başka bir yaklaşım bulun (`count()` kullanmadan).

<!-- 1.  Our definition of cancelled flights (`is.na(dep_delay) | is.na(arr_delay)` -->
<!--     ) is slightly suboptimal. Why? Which is the most important column? -->
    
1.  İptal edilen uçuşlar tanımımız (`is.na(dep_delay) | is.na(arr_delay)`) biraz standart altı. Neden? En önemli sütun hangisidir?

<!-- 1.  Look at the number of cancelled flights per day. Is there a pattern? -->
<!--     Is the proportion of cancelled flights related to the average delay? -->

1.  Günlük iptal edilen uçuş sayısına bakın. Bir örüntü var mı? İptal edilen uçuşların oranı ortalama gecikmeyle ilgili mi?

<!-- 1.  Which carrier has the worst delays? Challenge: can you disentangle the -->
<!--     effects of bad airports vs. bad carriers? Why/why not? (Hint: think about -->
<!--     `flights %>% group_by(carrier, dest) %>% summarise(n())`) -->
    
1.  Hangi taşıyıcı en kötü gecikmelere sahip? Meydan okuma: Kötü havaalanı ve kötü taşıyıcı etkisini birbirinden ayırabilir misiniz? Neden? (İpucu: `flights %>% group_by(carrier, dest) %>% summarise(n())` düşünün)

<!-- 1.  What does the `sort` argument to `count()` do. When might you use it? -->

1.  `sort` argümanı `count()`a ne yapar? Onu ne zaman kullanabilirsiniz?

<!-- ## Grouped mutates (and filters) -->

## Gruplanmış mutasyon (ve filtreler)

<!-- Grouping is most useful in conjunction with `summarise()`, but you can also do convenient operations with `mutate()` and `filter()`: -->

Gruplandırma en çok `summarise()` ile birlikte kullanıldığında kullanışlıdır, ancak `mutate()` ve `filter()` ile uygun işlemler yapabilirsiniz.

<!-- *   Find the worst members of each group: -->

*   Her grubun en kötü üyelerini bulun:

    ```{r}
    flights_sml %>% 
      group_by(year, month, day) %>%
      filter(rank(desc(arr_delay)) < 10)
    ```

<!-- *   Find all groups bigger than a threshold: -->

*   Bir eşikten büyük tüm grupları bulun:

    ```{r}
    popular_dests <- flights %>% 
      group_by(dest) %>% 
      filter(n() > 365)
    popular_dests
    ```

<!-- *   Standardise to compute per group metrics: -->

*   Grup başına ölçümleri hesaplamak için standardize edin:

    ```{r}
    popular_dests %>% 
      filter(arr_delay > 0) %>% 
      mutate(prop_delay = arr_delay / sum(arr_delay)) %>% 
      select(year:day, dest, arr_delay, prop_delay)
    ```

<!-- A grouped filter is a grouped mutate followed by an ungrouped filter. I generally avoid them except for quick and dirty manipulations: otherwise it's hard to check that you've done the manipulation correctly. -->

Gruplandırılmış bir filtre, gruplandırılmış bir mutasyon, ardından gruplanmamış bir filtredir. Ben hızlı ve kirli manipülasyonlar dışında genellikle onlardan kaçınıyorum: aksi takdirde manipülasyonu doğru yaptığınızı kontrol etmek zordur.

<!-- Functions that work most naturally in grouped mutates and filters are known as  window functions (vs. the summary functions used for summaries). You can learn more about useful window functions in the corresponding vignette: `vignette("window-functions")`. -->

Gruplanmış mutasyonlarda ve filtrelerde en doğal şekilde çalışan işlevler, pencere işlevleri olarak bilinir (özetler için kullanılan özet işlevlere karşılık). İlgili vinyette yararlı pencere işlevleri hakkında daha fazla bilgi edinebilirsiniz: `vignette("window-functions")`.

<!-- ### Exercises -->

### Alıştırmalar

<!-- 1.  Refer back to the lists of useful mutate and filtering functions.  -->
<!--     Describe how each operation changes when you combine it with grouping. -->

1.  Yararlı mutasyon ve filtreleme işlevleri listelerine bakın. Gruplandırmayla birleştirdiğinizde her işlemin nasıl değiştiğini açıklayın.

<!-- 1.  Which plane (`tailnum`) has the worst on-time record? -->

1.  Hangi uçak (`tailnum`) en kötü zamanında olma kaydına sahip?

<!-- 1.  What time of day should you fly if you want to avoid delays as much -->
<!--     as possible? -->

1.  Gecikmeleri mümkün olduğunca önlemek istiyorsanız günün hangi saatinde uçmalısınız?
    
<!-- 1.  For each destination, compute the total minutes of delay. For each  -->
<!--     flight, compute the proportion of the total delay for its destination. -->

1.  Her hedef için toplam gecikme dakikalarını hesaplayın. Her uçuşun varış yeri için toplam gecikme oranını hesaplayın.
    
<!-- 1.  Delays are typically temporally correlated: even once the problem that -->
<!--     caused the initial delay has been resolved, later flights are delayed  -->
<!--     to allow earlier flights to leave. Using `lag()`, explore how the delay -->
<!--     of a flight is related to the delay of the immediately preceding flight. -->
    
1.  Gecikmeler tipik olarak zamansal olarak ilişkilidir: ilk gecikmeye neden olan sorun çözüldüğünde bile, daha erken uçuşların kalkmasına izin vermek için sonraki uçuşlar da gecikir. `lag()` kullanarak, bir uçuşun gecikmesinin hemen önceki uçuşun gecikmesiyle nasıl ilişkili olduğunu keşfedin.
    
<!-- 1.  Look at each destination. Can you find flights that are suspiciously -->
<!--     fast? (i.e. flights that represent a potential data entry error). Compute -->
<!--     the air time a flight relative to the shortest flight to that destination. -->
<!--     Which flights were most delayed in the air? -->
    
1.  Her bir hedef yerine bakın. Şüpheli derecede hızlı uçuşlar bulabilir misiniz? (yani, potansiyel bir veri giriş hatasını temsil eden uçuşlar). Uçuş süresini, varış noktasına olan en kısa uçuşa göre hesaplayın. Havada en çok hangi uçuşlar gecikti?
    
<!-- 1.  Find all destinations that are flown by at least two carriers. Use that -->
<!--     information to rank the carriers. -->
    
1.  En az iki taşıyıcı tarafından yönlendirilen tüm varış noktalarını bulun. Bu bilgileri operatörleri sıralamak için kullanın.

<!-- 1.  For each plane, count the number of flights before the first delay  -->
<!--     of greater than 1 hour. -->
    
1.  Her uçak için, 1 saatten daha fazla olan ilk gecikmeden önceki uçuş sayısını hesaplayın.
